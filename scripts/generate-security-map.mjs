#!/usr/bin/env node
// Generate a minimal security map from an OpenAPI document (JSON or YAML)
// Usage: node scripts/generate-security-map.mjs [/absolute/or/relative/path/or/url]

import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';
import { createRequire } from 'node:module';

const require = createRequire(import.meta.url);
let YAML;
try {
  YAML = require('yaml');
} catch {}

const inputArg = process.argv[2] || 'https://docs.trustap.com/_spec/apis/openapi.yaml';

async function readOpenApi(source) {
  if (/^https?:\/\//.test(source)) {
    const res = await fetch(source);
    if (!res.ok) throw new Error(`Failed to fetch ${source}: ${res.status}`);
    const text = await res.text();
    if (source.endsWith('.yaml') || source.endsWith('.yml')) {
      if (!YAML) throw new Error('yaml package not available');
      return YAML.parse(text);
    }
    return JSON.parse(text);
  }
  const content = fs.readFileSync(source, 'utf8');
  if (source.endsWith('.yaml') || source.endsWith('.yml')) {
    if (!YAML) throw new Error('yaml package not available');
    return YAML.parse(content);
  }
  return JSON.parse(content);
}

function normalizeSecurityArray(secArr) {
  // Convert OpenAPI security array to a set of scheme names
  // e.g., [{ OAuth2: [] }, { APIKey: [] }] -> Set(['OAuth2','APIKey'])
  const set = new Set();
  if (Array.isArray(secArr)) {
    for (const entry of secArr) {
      if (entry && typeof entry === 'object') {
        for (const key of Object.keys(entry)) set.add(key);
      }
    }
  }
  return set;
}

function buildSecurityMap(doc) {
  const out = {}; // { path: { METHOD: ['APIKey','OAuth2'] } }
  const globalSec = normalizeSecurityArray(doc.security);
  const paths = doc.paths || {};
  for (const p of Object.keys(paths)) {
    const item = paths[p] || {};
    for (const method of Object.keys(item)) {
      const op = item[method];
      if (!op || typeof op !== 'object') continue;
      if (!['get','post','put','patch','delete','head','options','trace'].includes(method)) continue;
      const opSec = normalizeSecurityArray(op.security);
      const effective = opSec.size > 0 ? opSec : globalSec;
      if (!out[p]) out[p] = {};
      out[p][method.toUpperCase()] = Array.from(effective);
    }
  }
  return out;
}

function emitTs(securityMap) {
  const header = `// generated by scripts/generate-security-map.mjs\n`;
  const body = `export const securityMap = ${JSON.stringify(securityMap, null, 2)} as const;\n`;
  return header + body;
}

async function main() {
  const rootDir = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..');
  const outFile = path.join(rootDir, 'src', 'security-map.ts');
  const api = await readOpenApi(inputArg);
  const map = buildSecurityMap(api);
  const ts = emitTs(map);
  fs.writeFileSync(outFile, ts, 'utf8');
  console.log(`Wrote ${outFile}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});


